<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SVG Test</title>
    <style>
        #mySvg {
            width: 100vw;
            height: 100vh;
        }

        .handler {
            cursor: pointer;
        }
    </style>
</head>
<body>
<svg id="mySvg"></svg>
<script>
    const mySvg = document.querySelector("#mySvg");

    class SgItemNode {
        prev;
        next;
        item;
        /**
         * 操作类型
         * create <-> delete
         * modify <-> modify
         */
        operateType;
        capture;
        captureEnd;

        constructor(item) {
            this.item = item;
        }

        // setPrev(prevItem) {
        //
        // }

        setNext(nextItem) {
            this.next = nextItem;
            nextItem.prev = this;
        }


    }


    /**
     * 画图基类
     */
    class SgBaseItem {
        id;
        x;
        y;
        /**
         * 3种状态：
         * "": 正常
         * "moving": 移动状态（整体移动）
         * "editing": 选中状态（可进行大小调整）
         */
        state = "";
        editHandler = [];
        currentHandler;
        handlerMoving;
        capture;
        captureEnd;


        /**
         * 使用 ID 和位置初始化对象、
         * @param id
         * @param x
         * @param y
         */
        constructor({id, x, y}) {
            this.id = id;
            this.x = x;
            this.y = y;
        }

        /**
         * 用于响应移动事件。
         * 将本对象某某部位移动到哪个位置。
         * @param thing 部位名称
         * @param x 目标位置
         * @param y 目标位置
         */
        moveTo(thing, x, y) {
        }

        /**
         * 用于获取封装的图形元素
         */
        get inner() {
        }


        /**
         * 进入编辑模式
         */
        enableEdit() {
            this.state = "editing";
        }

        /**
         * 取消编辑模式
         */
        disableEdit() {
            this.state = "";
        }


        /**
         * 快捷初始化”把手“
         * @param count
         * @param x
         * @param y
         */
        initHandlers(count, x, y) {
            if (count > 0) {
                for (let i = 0; i < count; i++) {
                    this.editHandler.push(this.createHandler(x, y))
                }
            }
        }

        /**
         * 编辑“把手”
         * @param x
         * @param y
         * @returns {SVGCircleElement}
         */
        createHandler(x, y) {
            const handler = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            handler.setAttribute("cx", x);
            handler.setAttribute("cy", y);
            handler.setAttribute("stroke", "black");
            handler.setAttribute("r", "3");
            handler.setAttribute("fill", "white");
            handler.classList.add("handler");
            handler.parent = this;

            return handler;
        }
    }


    /**
     * 封装的直线类。
     */
    class SgLine extends SgBaseItem {
        endX;
        endY;
        lineObj;


        /**
         * 在构造函数中创建 svg 对象。
         * @param id
         * @param x
         * @param y
         */
        constructor({id, x, y}) {
            super({id, x, y});
            this.lineObj = document.createElementNS("http://www.w3.org/2000/svg", "line");
            this.lineObj.setAttribute("id", this.id);
            this.lineObj.setAttribute("x1", this.x);
            this.lineObj.setAttribute("y1", this.y);
            this.lineObj.setAttribute("stroke-width", "2");
            this.lineObj.setAttribute("stroke", "black");
            this.lineObj.classList.add("inner")
            this.lineObj.parent = this;

            // 初始化两个”把手“
            this.initHandlers(2, this.x, this.y);


            // 添加点击事件
            this.lineObj.addEventListener("click", (e) => {
                this.enableEdit();
            });
        }


        enableEdit() {
            super.enableEdit();
            this.editHandler.forEach((eh) => mySvg.appendChild(eh));
        }

        disableEdit() {
            super.disableEdit();
            this.editHandler.forEach((eh) => mySvg.removeChild(eh));
        }

        /**
         * 获取快照
         */
        takeCapture() {
            this.capture = this.lineObj.cloneNode(true);
            return this.capture;
        }

        recoveryFromCapture(capture) {
            mySvg.removeChild(this.inner);
            this.inner = capture;
            this.inner.parent = this;
            this.x = parseInt(this.inner.getAttribute("x1"));
            this.y = parseInt(this.inner.getAttribute("y1"));
            this.endX = parseInt(this.inner.getAttribute("x2"));
            this.endY = parseInt(this.inner.getAttribute("y2"));
            mySvg.appendChild(this.inner);
        }


        /**
         * 响应移动事件，默认移动末点。
         * @param thing
         * @param x
         * @param y
         */
        moveTo(thing, x, y) {
            switch (thing) {
                case "start":
                case this.editHandler[0]:
                    this.x = x;
                    this.y = y;
                    this.refreshStart();
                    break;
                case "end":
                case this.editHandler[1]:
                    this.endX = x;
                    this.endY = y;
                    this.refreshEnd();
                    break;
                case this:
                default:
                    // 整体移动
                    this.x += x;
                    this.y += y;
                    this.endX += x;
                    this.endY += y;
                    this.refreshStart();
                    this.refreshEnd();
            }
            myHand.addEdit(this);
        }

        remove() {
            mySvg.removeChild(this.inner);
        }

        show() {
            mySvg.appendChild(this.inner);
        }

        refreshStart() {
            this.lineObj.setAttribute("x1", this.x);
            this.lineObj.setAttribute("y1", this.y);
            const startHandler = this.editHandler[0];
            startHandler.setAttribute("cx", this.x);
            startHandler.setAttribute("cy", this.y);
        }

        refreshEnd() {
            this.lineObj.setAttribute("x2", this.endX);
            this.lineObj.setAttribute("y2", this.endY);
            const endHandler = this.editHandler[1];
            endHandler.setAttribute("cx", this.endX);
            endHandler.setAttribute("cy", this.endY);
        }


        /**
         * 返回 svg 封装的直线元素。
         * @returns {*}
         */
        get inner() {
            return this.lineObj;
        }

        set inner(inner) {
            this.lineObj = inner;
        }

    }


    /**
     * 记录当前活动
     */
    const myHand = {
        /**
         * 模式
         * "": 空模式
         * pen: 画笔模式
         *
         */
        mode: "pen",
        // 如果是 resize 或者 move，则标记为 modify
        modify: false,
        /**
         * 画笔模式下，可以确定绘画对象
         */
        type: "line",
        /**
         * 当前操作的对象，一般为鼠标按钮点下时的 e.target
         */
        obj: null,
        /**
         * 当前处于编辑状态的对象
         */
        edits: new Set(),
        /**
         * 用于记录鼠标点下时的 x 轴坐标
         */
        startX: 0,
        /**
         * 用于记录鼠标点下时的 y 轴坐标
         */
        startY: 0,
        /**
         * 记录鼠标按下状态
         */
        mousePressed: false,
        /**
         * 记录鼠标按下后，是否移动过，单次按压有效
         */
        mousePressingMove: false,
        /**
         * 操作栈
         * 对象指向头节点
         */
        nodeLinkList: null,
        /**
         * 当前操作节点
         */
        currentNode: null,

        /**
         * 将 SgItem 添加到操作栈中
         * @param sgItem
         */
        addNodeToLinkList(newCurrent) {
            // switch (newCurrent.operateType) {
            //     case  "create":
            //         console.log("创建");
            //         break;
            //     case "delete":
            //         console.log("删除");
            //         break;
            //     case "modify":
            //         console.log("修改");
            // }
            if (this.currentNode) {
                this.currentNode.setNext(newCurrent);
            }
            // 如果没有头节点
            if (!this.nodeLinkList) {
                this.nodeLinkList = newCurrent;
            }
            this.currentNode = newCurrent;
        },
        undo() {
            // console.log("撤销")
            if (this.currentNode) {
                myHand.clearEdit();
                switch (this.currentNode.operateType) {
                    case "create":
                        this.currentNode.item.remove();
                        break;
                    case "delete":
                        this.currentNode.item.show();
                        break;
                    case "modify":
                        this.currentNode.item.recoveryFromCapture(this.currentNode.capture);
                        break;
                    default:
                }
                this.currentNode = this.currentNode.prev;
            }
        },
        undoRemoveNode() {
            // console.log("反撤销")
            if (this.currentNode) {
                if (this.currentNode.next) {
                    this.currentNode = this.currentNode.next;
                }
            } else {
                if (this.nodeLinkList) {
                    this.currentNode = this.nodeLinkList;
                }
            }
            if (this.currentNode) {
                myHand.clearEdit();
                switch (this.currentNode.operateType) {
                    case "create":
                        this.currentNode.item.show();
                        break;
                    case "delete":
                        this.currentNode.item.delete();
                        break;
                    case "modify":
                        this.currentNode.item.recoveryFromCapture(this.currentNode.captureEnd);
                        break;
                    default:
                }
            }
        },


        /**
         * 清空已处于编辑状态的对象
         */
        clearEdit() {
            if (this.edits) {
                this.edits.forEach((ed) => ed.disableEdit());
                this.edits.clear();
            }
        },
        /**
         * 将当前对象添加到编辑队列中
         * @param sgNode
         */
        addEdit(sgNode) {
            sgNode.enableEdit();
            this.edits.add(sgNode);
        }

    }


    mySvg.addEventListener("mousedown", (e) => {
        // 监听鼠标按下事件，设置 myHand
        myHand.mousePressed = true;
        myHand.mousePressingMove = false;
        myHand.startX = e.offsetX;
        myHand.startY = e.offsetY;


        if (e.target.classList.contains("handler")) {
            // 如果点到 handler ，则切换成选择（调整）模式
            myHand.modify = true;
            // myHand.mode = "";
        }
        if (e.target.classList.contains("inner")) {
            myHand.modify = true;
            myHand.clearEdit();
        }
        if (e.target === mySvg) {
            myHand.clearEdit();
        } else {
            myHand.obj = e.target;
        }
    });
    mySvg.addEventListener("mousemove", (e) => {
        if (myHand.mousePressed) {
            // 只处理按下移动事件
            myHand.mousePressingMove = true;

            const mode = myHand.modify ? "modify" : myHand.mode;
            switch (mode) {
                case "pen":
                    // 绘画
                    // console.log("绘画")
                    if (!myHand.obj) {
                        myHand.obj = new SgLine({id: 1, x: e.offsetX, y: e.offsetY});
                        mySvg.appendChild(myHand.obj.inner);
                        // console.log("新建obj")
                    }
                    // console.log("移动obj")
                    myHand.obj.moveTo("end", e.offsetX, e.offsetY)
                    break;
                case "modify":
                    // console.log("拖拽")
                    // 拖拽
                    if (myHand.obj) {
                        // 如果拖到东西
                        if (myHand.obj.classList.contains("handler")) {
                            myHand.obj.parent.moveTo(myHand.obj, e.offsetX, e.offsetY);
                        }
                        if (myHand.obj.classList.contains("inner")) {
                            myHand.obj.parent.moveTo("", e.offsetX - myHand.startX, e.offsetY - myHand.startY);
                        }
                        myHand.startX = e.offsetX;
                        myHand.startY = e.offsetY;
                    }
                    break;
                case "":
                default:

            }
        }
    });
    mySvg.addEventListener("mouseup", (e) => {
        if (myHand.mousePressingMove) {
            // 拖动
            const mode = myHand.modify ? "modify" : myHand.mode;
            switch (mode) {
                case "pen":
                    if (myHand.obj) {
                        const currentNode = new SgItemNode(myHand.obj);
                        currentNode.operateType = "create";
                        myHand.obj.takeCapture();
                        myHand.addNodeToLinkList(currentNode);
                    }
                    break;
                case "modify":
                    if (myHand.obj) {
                        if (myHand.obj.classList.contains("handler") || myHand.obj.classList.contains("inner")) {
                            const sgItem = myHand.obj.parent;
                            const currentNode = new SgItemNode(sgItem);
                            currentNode.operateType = "modify";
                            currentNode.capture = sgItem.capture;
                            currentNode.captureEnd = sgItem.takeCapture();
                            myHand.addNodeToLinkList(currentNode);
                        }
                    }
                    break;
                default:
            }

        } else {
            // 点击
            if (e.target === mySvg) {
                myHand.clearEdit();
            }
            if (e.target.classList.contains("inner")) {
                myHand.clearEdit();
                myHand.edits.add(e.target.parent);
            }

        }
        // 重置 myHand
        myHand.obj = null;
        myHand.mousePressed = false;
        myHand.mousePressingMove = false;
        myHand.modify = false;
    });


    document.addEventListener("keypress", (e) => {
        if (e.ctrlKey && e.code === 'KeyZ') {
            myHand.clearEdit();
            if (e.shiftKey) {
                myHand.undoRemoveNode();
            } else {
                myHand.undo();
            }
        }
    })

</script>
</body>
</html>