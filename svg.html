<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SVG Test</title>
    <style>
        #mySvg {
            width: 100vw;
            height: 100vh;
        }

        .handler {
            cursor: pointer;
        }
    </style>
</head>
<body>
<svg id="mySvg"></svg>
<script>
    const mySvg = document.querySelector("#mySvg");


    /**
     * 操作栈对象
     */
    class SgItemNode {
        prevNode;
        nextNode;
        /**
         * 操作类型
         * create <-> delete
         * modify <-> modify
         */
        mode;
        // 快照
        capture;
        // 结束快照
        captureEnd;

        constructor(captureEnd) {
            this.captureEnd = captureEnd;
        }

        setNext(nextNode) {
            this.nextNode = nextNode;
            nextNode.prevNode = this;
        }
    }

    /**
     * 记录当前活动
     */
    const myHand = {
        // create / delete / modify
        mode: "",
        /**
         * 当前鼠标类型，为空则表示选择模式
         */
        type: "line",
        /**
         * 当前操作的对象，一般为鼠标按钮点下时的 e.target
         */
        obj: null,
        /**
         * 现有把手，用于维护编辑状态的所有对象
         */
        handlers: [],
        /**
         * 用于记录 x 轴坐标
         * 绘图时：用作记录原点
         * 拖动时：可以复用为上一次移动的点
         */
        startX: 0,
        /**
         * 用于记录 y 轴坐标
         * 绘图时：用作记录原点
         * 拖动时：可以复用为上一次移动的点
         */
        startY: 0,

        /**
         * 记录鼠标按下状态
         */
        mousePressed: false,
        /**
         * 记录鼠标按下后，是否移动过，单次按压有效
         */
        mousePressingMove: false,
        /**
         * 操作栈
         * 对象指向头节点
         */
        nodeLinkList: null,
        /**
         * 当前操作节点
         */
        currentNode: null,
        /**
         * 临时快照
         */
        capture: null,


        /**
         * 将 Node 添加到操作栈中
         */
        addNodeToLinkList(newCurrent) {
            if (this.currentNode) {
                this.currentNode.setNext(newCurrent);
            }
            // 如果没有头节点
            if (!this.nodeLinkList) {
                this.nodeLinkList = newCurrent;
            }
            this.currentNode = newCurrent;
        },
        /**
         * 撤销
         */
        undo() {
            // console.log("撤销")
            if (this.currentNode) {
                myHand.clearHandlers();
                switch (this.currentNode.mode) {
                    case "create":
                        for (let obj of this.currentNode.captureEnd) {
                            mySvg.removeChild(mySvg.querySelector(`#${obj.getAttribute("id")}`));
                        }
                        break;
                    case "delete":
                        for (let obj of this.currentNode.capture) {
                            mySvg.appendChild(obj);
                        }
                        break;
                    case "modify":
                        for (let obj of this.currentNode.captureEnd) {
                            mySvg.removeChild(mySvg.querySelector(`#${obj.getAttribute("id")}`));
                        }
                        for (let obj of this.currentNode.capture) {
                            mySvg.appendChild(obj);
                        }
                        break;
                    default:
                }
                this.currentNode = this.currentNode.prevNode;
            }
        },
        /**
         * 反撤销
         */
        undoRemoveNode() {
            if (this.currentNode) {
                if (this.currentNode.nextNode) {
                    this.currentNode = this.currentNode.nextNode;
                } else {
                    return;
                }
            } else {
                if (this.nodeLinkList) {
                    this.currentNode = this.nodeLinkList;
                }
            }
            if (this.currentNode) {
                myHand.clearHandlers();
                switch (this.currentNode.mode) {
                    case "create":
                        for (let obj of this.currentNode.captureEnd) {
                            mySvg.appendChild(obj);
                        }
                        break;
                    case "delete":
                        for (let obj of this.currentNode.capture) {
                            mySvg.removeChild(mySvg.querySelector(`#${obj.getAttribute("id")}`));
                        }
                        break;
                    case "modify":
                        for (let obj of this.currentNode.capture) {
                            mySvg.removeChild(mySvg.querySelector(`#${obj.getAttribute("id")}`));
                        }
                        for (let obj of this.currentNode.captureEnd) {
                            mySvg.appendChild(obj);
                        }

                        break;
                    default:
                }
            }
        },
        /**
         * 判断当前对象是否处于编辑状态
         * @param obj
         * @returns {boolean}
         */
        isEditing(obj) {
            for (let i = 0; i < this.handlers.length; i++) {
                if (this.handlers[i].parent === obj) {
                    return true;
                }
            }
            return false;
        },
        /**
         * 为当前对象添加把手
         * @param obj
         * @returns {SVGCircleElement}
         */
        addHandlersByObj(obj) {
            let defaultHandler = null;
            switch (obj.getAttribute("type")) {
                case "line":
                    this.handlers.push(createHandler(obj, "x1", "y1"),
                        defaultHandler = createHandler(obj, "x2", "y2"));
                    return defaultHandler;
            }
        },
        /**
         * 清空所有对象编辑状态
         */
        clearHandlers() {
            if (this.handlers) {
                this.handlers.forEach(h => mySvg.removeChild(h));
                this.handlers.splice(0);
            }
        },
        /**
         * 以当前把手所指对象创建快照
         * @returns {*[]}
         */
        takeCapture() {
            // 当前编辑对象快照
            const captures = []
            if (this.handlers) {
                new Set(this.handlers.map((h) => h.parent)).forEach((obj) => {
                    captures.push(obj.cloneNode(true));
                });
            }
            return captures;
        },
        /**
         * 重置 myHand 状态，一般用于鼠标点击之后
         */
        resetHand() {
            this.obj = null;
            this.mousePressed = false;
            this.mousePressingMove = false;
            this.capture = null;
            this.mode = "";
        }

    }

    /**
     * 创建“把手”
     */
    function createHandler(parent, xBindTo, yBindTo) {
        const handler = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        handler.setAttribute("xBindTo", xBindTo);
        handler.setAttribute("yBindTo", yBindTo);
        handler.setAttribute("cx", parent.getAttribute(xBindTo));
        handler.setAttribute("cy", parent.getAttribute(yBindTo));
        handler.setAttribute("stroke", "black");
        handler.setAttribute("r", "3");
        handler.setAttribute("fill", "white");
        handler.classList.add("handler");
        handler.parent = parent;
        mySvg.appendChild(handler);
        /**
         * 将当前把手移动到指定地点，顺带移动绑定的图形对象
         * @param x
         * @param y
         */
        handler.moveTo = function (x, y) {
            this.setAttribute("cx", x);
            this.setAttribute("cy", y);
            this.parent.setAttribute(this.getAttribute("xBindTo"), x);
            this.parent.setAttribute(this.getAttribute("yBindTo"), y);
        };
        /**
         * 使用偏移量移动把手，顺带移动绑定的图形对象
         * @param offsetX
         * @param offsetY
         */
        handler.moveByOffset = function (offsetX, offsetY) {
            const x = parseInt(this.getAttribute("cx")) + offsetX;
            const y = parseInt(this.getAttribute("cy")) + offsetY;
            this.setAttribute("cx", x);
            this.setAttribute("cy", y);
            this.parent.setAttribute(this.getAttribute("xBindTo"), x);
            this.parent.setAttribute(this.getAttribute("yBindTo"), y);
        }

        return handler;
    }

    /**
     * 动态创建对象，同时使用 option 动态设置属性
     * @param type
     * @param option
     * @returns {*}
     */
    function createObjectBy(type, option) {
        const drawObj = document.createElementNS("http://www.w3.org/2000/svg", type);
        for (const [key, value] of Object.entries(option)) {
            drawObj.setAttribute(key, value);
        }
        drawObj.setAttribute("stroke-width", "2");
        drawObj.setAttribute("stroke", "black");
        drawObj.setAttribute("id", getId());
        return drawObj;
    }

    /**
     * 获取唯一ID
     * @returns {string}
     */
    function getId() {
        return `UID${(new Date()).getTime()}`;
    }


    mySvg.addEventListener("mousedown", (e) => {
        // 监听鼠标按下事件，设置 myHand
        myHand.mousePressed = true;
        myHand.mousePressingMove = false;
        myHand.startX = e.offsetX;
        myHand.startY = e.offsetY;

        myHand.obj = e.target;
    });
    mySvg.addEventListener("mousemove", (e) => {
        if (myHand.mousePressed) {
            // 只处理按下移动事件
            myHand.mousePressingMove = true;

            if (myHand.obj.classList.contains("handler")) {
                if (!myHand.mode) {
                    // 把当前选中的对象，创建快照
                    myHand.capture = myHand.takeCapture();
                    myHand.mode = "modify";
                }
                myHand.obj.moveTo(e.offsetX, e.offsetY)
            } else {
                if (myHand.type) {
                    myHand.clearHandlers();
                    const drawObj = createObjectBy(myHand.type, {
                        x1: myHand.startX,
                        y1: myHand.startY,
                        x2: e.offsetX,
                        y2: e.offsetY,
                        type: myHand.type
                    });
                    mySvg.appendChild(drawObj);
                    myHand.mode = "create";
                    myHand.obj = myHand.addHandlersByObj(drawObj);
                } else {
                    if (myHand.obj === mySvg) {
                        // todo 绘制选区
                    } else {
                        if (!myHand.isEditing(myHand.obj)) {
                            myHand.clearHandlers();
                            myHand.addHandlersByObj(myHand.obj);
                        }
                        if (myHand.mode !== "modify") {
                            // 把当前选中的对象，创建快照
                            myHand.capture = myHand.takeCapture();
                            myHand.mode = "modify";
                        }

                        for (let i = 0; i < myHand.handlers.length; i++) {
                            myHand.handlers[i].moveByOffset(e.offsetX - myHand.startX, e.offsetY - myHand.startY);
                        }
                        myHand.startX = e.offsetX;
                        myHand.startY = e.offsetY;
                    }
                }

            }
        }
    });
    mySvg.addEventListener("mouseup", (e) => {
        if (myHand.mousePressingMove) {
            if (myHand.obj === mySvg) {
                // todo 设置选取内的图形为唯一选中
            } else {
                const captureEnd = myHand.takeCapture();
                let sgNode = new SgItemNode(captureEnd);
                sgNode.mode = myHand.mode;
                sgNode.capture = myHand.capture;
                myHand.addNodeToLinkList(sgNode);
            }
        } else {
            if (myHand.obj === mySvg) {
                myHand.clearHandlers();
            }
            // 点击事件
            if (myHand.obj !== mySvg && !myHand.obj.classList.contains("handler")) {
                // 既不是 svg 也不是 handler，只能是图形对象
                myHand.clearHandlers();
                myHand.addHandlersByObj(myHand.obj);
            }
        }

        // 重置 myHand
        myHand.resetHand();
    });


    /**
     * 响应键盘事件
     */
    document.addEventListener("keypress", (e) => {
        if (e.code === "Space") {
            myHand.type = myHand.type ? "" : "line";
            return;
        }
        if (e.ctrlKey && e.code === "KeyZ") {
            myHand.clearHandlers();
            if (e.shiftKey) {
                myHand.undoRemoveNode();
            } else {
                myHand.undo();
            }
        }
    })

</script>
</body>
</html>